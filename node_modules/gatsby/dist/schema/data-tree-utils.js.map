{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","invariant","createKey","typeConflictReporter","DateType","is32BitInteger","INVALID_VALUE","Symbol","isDefined","v","isEmptyObjectOrArray","obj","isDate","isObject","isEmpty","every","value","key","isScalar","val","Date","extractTypes","Array","isArray","uniqueTypes","uniq","filter","map","item","type","sort","join","arrayTypes","isMixOfDateObjectsAndDateStrings","values","length","includes","allValuesAreDates","shouldInfer","conflictIsValidSpecialCase","entries","entriesOfUniqueType","isConsistentlyScalarOrArray","entry","getExampleScalarFromArray","reduce","nextValue","isNumber","extractFromEntries","selector","uniqBy","addConflict","exampleValue","concatanedItems","extractFromArrays","isPlainObject","extractFieldExamples","filteredItems","flattenEntries","parent","arrayItemExample","nodes","ignoreFields","allKeys","flatMap","keys","example","nextSelector","nodeWithValues","node","buildFieldEnumValues","options","enumValues","getExampleValues","maxDepth","safe","delimiter","Object","forEach","field","typeExampleValues","Map","clearTypeExampleValues","clear","clearConflicts","typeName","cachedValue","get","set","extractFieldNames","module","exports"],"mappings":";;AACA,MAAMA,IAAIC,QAAS,QAAT,CAAV;;AACA,MAAMC,UAAUD,QAAS,MAAT,CAAhB;;AACA,MAAME,SAASF,QAAS,SAAT,CAAf;;AACA,MAAMG,YAAYH,QAAS,WAAT,CAAlB;;AAEA,MAAMI,YAAYJ,QAAS,cAAT,CAAlB;;iBACiCA,QAAS,0BAAT,C;MAAzBK,oB,YAAAA,oB;;AACR,MAAMC,WAAWN,QAAS,mBAAT,CAAjB;;AACA,MAAMO,iBAAiBP,QAAS,4BAAT,CAAvB;;AAMA,MAAMQ,gBAAgBC,OAAQ,eAAR,CAAtB;;AACA,MAAMC,YAAYC,KAAKA,KAAK,IAA5B;;AAEA,MAAMC,uBAAwBC,GAAD,IAAuB;AAClD,MAAIA,QAAQL,aAAZ,EAA2B;AACzB,WAAO,IAAP;AACD,GAFD,MAEO,IAAIT,EAAEe,MAAF,CAASD,GAAT,CAAJ,EAAmB;AACxB,WAAO,KAAP,CADwB,CAExB;AACD,GAHM,MAGA,IAAId,EAAEgB,QAAF,CAAWF,GAAX,KAAmBd,EAAEiB,OAAF,CAAUH,GAAV,CAAvB,EAAuC;AAC5C,WAAO,IAAP;AACD,GAFM,MAEA,IAAId,EAAEgB,QAAF,CAAWF,GAAX,CAAJ,EAAqB;AAC1B,WAAOd,EAAEkB,KAAF,CAAQJ,GAAR,EAAa,CAACK,KAAD,EAAQC,GAAR,KAAgB;AAClC,UAAI,CAACT,UAAUQ,KAAV,CAAL,EAAuB;AACrB,eAAO,IAAP;AACD,OAFD,MAEO,IAAInB,EAAEgB,QAAF,CAAWG,KAAX,CAAJ,EAAuB;AAC5B,eAAON,qBAAqBM,KAArB,CAAP;AACD,OAFM,MAEA;AACL,eAAO,KAAP;AACD;AACF,KARM,CAAP;AASD;;AACD,SAAO,KAAP;AACD,CApBD;;AAsBA,MAAME,WAAWC,OAAO,CAACtB,EAAEgB,QAAF,CAAWM,GAAX,CAAD,IAAoBA,eAAeC,IAA3D;;AAEA,MAAMC,eAAeL,SAAS;AAC5B,MAAIM,MAAMC,OAAN,CAAcP,KAAd,CAAJ,EAA0B;AACxB,UAAMQ,cAAc3B,EAAE4B,IAAF,CAClBT,MAAMU,MAAN,CAAalB,SAAb,EAAwBmB,GAAxB,CAA4BC,QAAQP,aAAaO,IAAb,EAAmBC,IAAvD,CADkB,EAElBC,IAFkB,EAApB;;AAGA,WAAO;AACLD,YAAO,SAAQL,YAAYO,IAAZ,CAAkB,GAAlB,CAAsB,GADhC;AAELC,kBAAYR;AAFP,KAAP;AAID,GARD,MAQO;AACL,UAAMK,OAAO7B,OAAOgB,KAAP,CAAb;AACA,WAAO;AACLa,UADK;AAELG,kBAAY;AAFP,KAAP;AAID;AACF,CAhBD;;AAkBA,MAAMC,mCAAmC,CACvCC,MADuC,EAEvCV,WAFuC,KAG3B;AACZ,MACEA,YAAYW,MAAZ,KAAuB,CAAvB,IACAX,YAAYY,QAAZ,CAAsB,QAAtB,CADA,IAEAZ,YAAYY,QAAZ,CAAsB,MAAtB,CAHF,EAIE;AACA,UAAMC,oBAAoBH,OAAOnB,KAAP,CAAaC,SAAS;AAC9C,UAAIhB,OAAOgB,KAAP,MAAmB,MAAvB,EAA8B,OAAO,IAAP,CADgB,CAG9C;;AACA,aAAOZ,SAASkC,WAAT,CAAqBtB,KAArB,CAAP;AACD,KALyB,CAA1B;AAOA,WAAOqB,iBAAP;AACD;;AAED,SAAO,KAAP;AACD,CApBD;;AAsBA,MAAME,6BAA6B,CACjCC,OADiC,EAEjCC,mBAFiC,KAGrB;AACZ,QAAMC,8BAA8BD,oBAAoB1B,KAApB,CAClC4B,SACEA,MAAMX,UAAN,CAAiBG,MAAjB,GAA0B,CAA1B,KACAM,oBAAoB,CAApB,EAAuBT,UAAvB,CAAkCG,MAAlC,GAA2C,CAHX,CAApC;;AAKA,MAAIO,2BAAJ,EAAiC;AAC/B;AACA;AACA;AAGA,QAAIlB,WAAJ;AACA,QAAIU,MAAJ;AACA,UAAMX,UAAUkB,oBAAoB,CAApB,EAAuBT,UAAvB,CAAkCG,MAAlC,GAA2C,CAA3D;;AAEA,QAAIZ,OAAJ,EAAa;AACXW,eAASrC,EAAEE,OAAF,CAAUyC,QAAQb,GAAR,CAAYgB,SAASA,MAAM3B,KAA3B,CAAV,CAAT;AACAQ,oBAAc3B,EAAE4B,IAAF,CACZ5B,EAAEE,OAAF,CAAU0C,oBAAoBd,GAApB,CAAwBgB,SAASA,MAAMX,UAAvC,CAAV,CADY,CAAd;AAGD,KALD,MAKO;AACLE,eAASM,QAAQb,GAAR,CAAYgB,SAASA,MAAM3B,KAA3B,CAAT;AACAQ,oBAAciB,oBAAoBd,GAApB,CAAwBgB,SAASA,MAAMd,IAAvC,CAAd;AACD;;AAED,WAAOI,iCAAiCC,MAAjC,EAAyCV,WAAzC,CAAP;AACD;;AACD,SAAO,KAAP;AACD,CAhCD;;AAkCA,MAAMoB,4BAA4BV,UAChCrC,EAAEgD,MAAF,CACEX,MADF,EAEE,CAAClB,KAAD,EAAQ8B,SAAR,KAAsB;AACpB;AACA,MAAIA,aAAajD,EAAEkD,QAAF,CAAWD,SAAX,CAAb,IAAsC,CAACzC,eAAeyC,SAAf,CAA3C,EAAsE;AACpE,WAAOA,SAAP;AACD,GAFD,MAEO,IAAI9B,UAAU,IAAd,EAAoB;AACzB,WAAO8B,SAAP;AACD,GAFM,MAEA;AACL,WAAO9B,KAAP;AACD;AACF,CAXH,EAYE,IAZF,CADF;;AAgBA,MAAMgC,qBAAqB,CACzBR,OADyB,EAEzBS,QAFyB,EAGzBhC,GAHyB,KAId;AACX,QAAMwB,sBAAsB5C,EAAEqD,MAAF,CAASV,OAAT,EAAkBG,SAASA,MAAMd,IAAjC,CAA5B;;AAEA,MAAIY,oBAAoBN,MAApB,IAA8B,CAAlC,EAAqC;AACnC;AACA,WAAO,IAAP;AACD,GAHD,MAGO,IACLM,oBAAoBN,MAApB,GAA6B,CAA7B,IACAM,oBAAoB,CAApB,EAAuBT,UAAvB,CAAkCG,MAAlC,GAA2C,CAFtC,EAGL;AACA;AACA;AACA,QAAI,CAACI,2BAA2BC,OAA3B,EAAoCC,mBAApC,CAAL,EAA+D;AAC7D,UAAIQ,QAAJ,EAAc;AACZ9C,6BAAqBgD,WAArB,CAAiCF,QAAjC,EAA2CR,mBAA3C;AACD;;AACD,aAAOnC,aAAP;AACD;AACF,GAlBU,CAoBX;;;AACA,QAAM4B,SAASM,QAAQb,GAAR,CAAYgB,SAASA,MAAM3B,KAA3B,CAAf;AAEA,QAAMoC,eAAeX,oBAAoB,CAApB,EAAuBzB,KAA5C;;AAEA,MAAIE,SAASkC,YAAT,CAAJ,EAA4B;AAC1B,WAAOR,0BAA0BV,MAA1B,CAAP;AACD,GAFD,MAEO,IAAIrC,EAAEgB,QAAF,CAAWuC,YAAX,CAAJ,EAA8B;AACnC,QAAI9B,MAAMC,OAAN,CAAc6B,YAAd,CAAJ,EAAiC;AAC/B,YAAMC,kBAAkBxD,EAAEE,OAAF,CAAUmC,MAAV,CAAxB,CAD+B,CAE/B;AACA;;;AACA,UAAIjB,IAAImB,QAAJ,CAAc,SAAd,CAAJ,EAA6B;AAC3B,eAAOiB,eAAP;AACD;;AAED,aAAOC,kBAAkBD,eAAlB,EAAmCb,OAAnC,EAA4CS,QAA5C,CAAP;AACD,KATD,MASO,IAAIpD,EAAE0D,aAAF,CAAgBH,YAAhB,CAAJ,EAAmC;AACxC,aAAOI,qBAAqBtB,MAArB,EAA6Be,QAA7B,CAAP;AACD;AACF,GAxCU,CAyCX;;;AACA,SAAO3C,aAAP;AACD,CA/CD;;AAiDA,MAAMgD,oBAAoB,CAACpB,MAAD,EAASM,OAAT,EAA+BS,QAA/B,KAAoD;AAC5E,QAAMQ,gBAAgBvB,OAAOR,MAAP,CAAclB,SAAd,CAAtB;;AACA,MAAIiD,cAActB,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,WAAO,IAAP;AACD;;AACD,MAAIjB,SAASuC,cAAc,CAAd,CAAT,CAAJ,EAAgC;AAC9B,WAAO,CAACb,0BAA0Ba,aAA1B,CAAD,CAAP;AACD;;AAED,QAAMC,iBAA8B7D,EAAEE,OAAF,CAClCyC,QAAQb,GAAR,CAAYgB,SAAS;AACnB1C,cACEqB,MAAMC,OAAN,CAAcoB,MAAM3B,KAApB,CADF,EAEG,wCAFH;AAKA,WAAO2B,MAAM3B,KAAN,CAAYW,GAAZ,CAAgBX,SAAS;AAC9B;AACEA,aADF;AAEE2C,gBAAQhB,MAAMgB;AAFhB,SAGKtC,aAAaL,KAAb,CAHL;AAKD,KANM,CAAP;AAOD,GAbD,CADkC,CAApC;;AAiBA,QAAM4C,mBAAmBZ,mBACvBU,cADuB,EAEtB,GAAET,QAAS,IAFW,EAGtB,EAHsB,CAAzB;;AAKA,MAAI,CAACzC,UAAUoD,gBAAV,CAAD,IAAgCA,qBAAqBtD,aAAzD,EAAwE;AACtE,WAAOA,aAAP;AACD;;AAED,SAAO,CAACsD,gBAAD,CAAP;AACD,CApCD;AAsCA;;;;;;;;;;;;;;AAYA,MAAMJ,uBAAuB,CAC3BK,KAD2B,EAE3BZ,QAF2B,EAG3Ba,eAA0B,EAHC,KAIV;AACjB;AACA,QAAMC,UAAUlE,EAAEgE,KAAF,EACbG,OADa,CACLnE,EAAEoE,IADG,EAEbxC,IAFa,EAAhB;;AAIA,QAAMyC,UAAU,EAAhB;;AACA,uBAAgBH,OAAhB,kHAAyB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,QAAhB9C,GAAgB;AACvB,QAAI6C,aAAa1B,QAAb,CAAsBnB,GAAtB,CAAJ,EAAgC;AAChC,UAAMkD,eAAelB,WAAY,GAAEA,QAAS,IAAGhC,GAAI,EAA9B,GAAkCA,GAAvD;AAEA,UAAMmD,iBAAiBP,MAAMnC,MAAN,CAAa2C,QAAQ;AAC1C,UAAI,CAACA,IAAL,EAAW,OAAO,KAAP;AAEX,YAAMrD,QAAQqD,KAAKpD,GAAL,CAAd;;AACA,UAAIpB,EAAEgB,QAAF,CAAWG,KAAX,CAAJ,EAAuB;AACrB,eAAO,CAACN,qBAAqBM,KAArB,CAAR;AACD,OAFD,MAEO;AACL,eAAOR,UAAUQ,KAAV,CAAP;AACD;AACF,KATsB,CAAvB,CAJuB,CAevB;;AACA,UAAMwB,UAAU4B,eAAezC,GAAf,CAAmB0C,QAAQ;AACzC,YAAMrD,QAAQqD,KAAKpD,GAAL,CAAd;AACA;AACED,aADF;AAEE2C,gBAAQU;AAFV,SAGKhD,aAAaL,KAAb,CAHL;AAKD,KAPe,CAAhB;AASA,UAAMA,QAAQgC,mBAAmBR,OAAnB,EAA4B2B,YAA5B,EAA0ClD,GAA1C,CAAd;AACA,QAAI,CAACT,UAAUQ,KAAV,CAAL,EAAuB;AAEvBkD,YAAQjD,GAAR,IAAeD,KAAf;AACD;;AAED,SAAOkD,OAAP;AACD,CA3CD;;AA6CA,MAAMI,uBAAwBC,OAAD,IAAkC;AAC7D,QAAMC,aAAa,EAAnB;AACA,QAAMtC,SAASnC,QAAQ0E,iBAAiBF,OAAjB,CAAR,EAAmC;AAChDG,cAAU,CADsC;AAEhDC,UAAM,IAF0C;AAEpC;AACZC,eAAY;AAHoC,GAAnC,CAAf;AAKAC,SAAOZ,IAAP,CAAY/B,MAAZ,EAAoB4C,OAApB,CAA4BC,SAAS;AACnC,QAAI7C,OAAO6C,KAAP,KAAiB,IAArB,EAA2B;AAC3BP,eAAWtE,UAAU6E,KAAV,CAAX,IAA+B;AAAEA;AAAF,KAA/B;AACD,GAHD;AAKA,SAAOP,UAAP;AACD,CAbD;;AAeA,IAAIQ,oBAAyC,IAAIC,GAAJ,EAA7C;;AAEA,MAAMC,yBAAyB,MAAM;AACnCF,oBAAkBG,KAAlB;AACAhF,uBAAqBiF,cAArB;AACD,CAHD;;AAWA,MAAMX,mBAAmB,CAAC;AACxBZ,OADwB;AAExBwB,UAFwB;AAGxBvB;AAHwB,CAAD,KAIgB;AACvC,QAAMwB,cAAcD,YAAYL,kBAAkBO,GAAlB,CAAsBF,QAAtB,CAAhC,CADuC,CAGvC;;AACA,MAAIC,WAAJ,EAAiB,OAAOA,WAAP,CAJsB,CAMvC;;AACA,MAAIzB,SAASA,MAAM1B,MAAN,GAAe,CAA5B,EAA+B;AAC7B,UAAMiB,eAAeI,qBACnBK,KADmB,EAEnBwB,YAAa,EAFM,EAGnBvB,YAHmB,CAArB,CAD6B,CAM7B;;AACA,QAAIuB,QAAJ,EAAcL,kBAAkBQ,GAAlB,CAAsBH,QAAtB,EAAgCjC,YAAhC;AACd,WAAOA,YAAP;AACD;;AAED,SAAO,EAAP;AACD,CAvBD,C,CAyBA;AACA;AACA;;;AACA,MAAMqC,oBAAqB5B,KAAD,IAAqB;AAC7C,QAAM3B,SAASnC,QACb0E,iBAAiB;AACfZ,SADe;AAEfwB,cAAUxF,EAAE0F,GAAF,CAAM1B,MAAM,CAAN,CAAN,EAAiB,eAAjB;AAFK,GAAjB,CADa,EAKb;AACEa,cAAU,CADZ;AAEEC,UAAM,IAFR;AAEc;AACZC,eAAY;AAHd,GALa,CAAf;AAYA,SAAOC,OAAOZ,IAAP,CAAY/B,MAAZ,CAAP;AACD,CAdD;;AAgBAwD,OAAOC,OAAP,GAAiB;AACfrF,eADe;AAEfgE,sBAFe;AAGfmB,mBAHe;AAIf/E,sBAJe;AAKfwE,wBALe;AAMfT;AANe,CAAjB","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\nconst invariant = require(`invariant`)\n\nconst createKey = require(`./create-key`)\nconst { typeConflictReporter } = require(`./type-conflict-reporter`)\nconst DateType = require(`./types/type-date`)\nconst is32BitInteger = require(`../utils/is-32-bit-integer`)\n\nimport type { TypeEntry } from \"./type-conflict-reporter\"\n\ntype ExampleValue = Object\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n  } else if (_.isDate(obj)) {\n    return false\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\nconst isScalar = val => !_.isObject(val) || val instanceof Date\n\nconst extractTypes = value => {\n  if (Array.isArray(value)) {\n    const uniqueTypes = _.uniq(\n      value.filter(isDefined).map(item => extractTypes(item).type)\n    ).sort()\n    return {\n      type: `array<${uniqueTypes.join(`|`)}>`,\n      arrayTypes: uniqueTypes,\n    }\n  } else {\n    const type = typeOf(value)\n    return {\n      type,\n      arrayTypes: [],\n    }\n  }\n}\n\nconst isMixOfDateObjectsAndDateStrings = (\n  values: any[],\n  uniqueTypes: string[]\n): boolean => {\n  if (\n    uniqueTypes.length === 2 &&\n    uniqueTypes.includes(`string`) &&\n    uniqueTypes.includes(`date`)\n  ) {\n    const allValuesAreDates = values.every(value => {\n      if (typeOf(value) === `date`) return true\n\n      // use infer checker to determine if string is a date\n      return DateType.shouldInfer(value)\n    })\n\n    return allValuesAreDates\n  }\n\n  return false\n}\n\nconst conflictIsValidSpecialCase = (\n  entries: TypeEntry[],\n  entriesOfUniqueType: TypeEntry[]\n): boolean => {\n  const isConsistentlyScalarOrArray = entriesOfUniqueType.every(\n    entry =>\n      entry.arrayTypes.length > 0 ===\n      entriesOfUniqueType[0].arrayTypes.length > 0\n  )\n  if (isConsistentlyScalarOrArray) {\n    // Get values and run them through special cases, to see if there actually\n    // is a conflict. This is done so late in process, because those checks\n    // would be expensive to do earlier during extraction, so we do them\n    // only when we have potential conflict.\n\n    let uniqueTypes: string[]\n    let values: any[]\n    const isArray = entriesOfUniqueType[0].arrayTypes.length > 0\n\n    if (isArray) {\n      values = _.flatten(entries.map(entry => entry.value))\n      uniqueTypes = _.uniq(\n        _.flatten(entriesOfUniqueType.map(entry => entry.arrayTypes))\n      )\n    } else {\n      values = entries.map(entry => entry.value)\n      uniqueTypes = entriesOfUniqueType.map(entry => entry.type)\n    }\n\n    return isMixOfDateObjectsAndDateStrings(values, uniqueTypes)\n  }\n  return false\n}\n\nconst getExampleScalarFromArray = values =>\n  _.reduce(\n    values,\n    (value, nextValue) => {\n      // Prefer floats over ints as they're more specific.\n      if (nextValue && _.isNumber(nextValue) && !is32BitInteger(nextValue)) {\n        return nextValue\n      } else if (value === null) {\n        return nextValue\n      } else {\n        return value\n      }\n    },\n    null\n  )\n\nconst extractFromEntries = (\n  entries: TypeEntry[],\n  selector: string,\n  key: string\n): ?mixed => {\n  const entriesOfUniqueType = _.uniqBy(entries, entry => entry.type)\n\n  if (entriesOfUniqueType.length == 0) {\n    // skip if no defined types\n    return null\n  } else if (\n    entriesOfUniqueType.length > 1 ||\n    entriesOfUniqueType[0].arrayTypes.length > 1\n  ) {\n    // there is multiple types or array of multiple types\n    // that aren't handled by any special case\n    if (!conflictIsValidSpecialCase(entries, entriesOfUniqueType)) {\n      if (selector) {\n        typeConflictReporter.addConflict(selector, entriesOfUniqueType)\n      }\n      return INVALID_VALUE\n    }\n  }\n\n  // Now we have entries of single type, we can merge them\n  const values = entries.map(entry => entry.value)\n\n  const exampleValue = entriesOfUniqueType[0].value\n\n  if (isScalar(exampleValue)) {\n    return getExampleScalarFromArray(values)\n  } else if (_.isObject(exampleValue)) {\n    if (Array.isArray(exampleValue)) {\n      const concatanedItems = _.flatten(values)\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (key.includes(`___NODE`)) {\n        return concatanedItems\n      }\n\n      return extractFromArrays(concatanedItems, entries, selector)\n    } else if (_.isPlainObject(exampleValue)) {\n      return extractFieldExamples(values, selector)\n    }\n  }\n  // unsuported object\n  return INVALID_VALUE\n}\n\nconst extractFromArrays = (values, entries: TypeEntry[], selector: string) => {\n  const filteredItems = values.filter(isDefined)\n  if (filteredItems.length === 0) {\n    return null\n  }\n  if (isScalar(filteredItems[0])) {\n    return [getExampleScalarFromArray(filteredItems)]\n  }\n\n  const flattenEntries: TypeEntry[] = _.flatten(\n    entries.map(entry => {\n      invariant(\n        Array.isArray(entry.value),\n        `this is validated in the previous call`\n      )\n\n      return entry.value.map(value => {\n        return {\n          value,\n          parent: entry.parent,\n          ...extractTypes(value),\n        }\n      })\n    })\n  )\n\n  const arrayItemExample = extractFromEntries(\n    flattenEntries,\n    `${selector}[]`,\n    ``\n  )\n  if (!isDefined(arrayItemExample) || arrayItemExample === INVALID_VALUE) {\n    return INVALID_VALUE\n  }\n\n  return [arrayItemExample]\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (\n  nodes: any[],\n  selector: string,\n  ignoreFields?: string[] = []\n): ExampleValue => {\n  // get list of keys in all nodes\n  const allKeys = _(nodes)\n    .flatMap(_.keys)\n    .uniq()\n\n  const example = {}\n  for (let key of allKeys) {\n    if (ignoreFields.includes(key)) continue\n    const nextSelector = selector ? `${selector}.${key}` : key\n\n    const nodeWithValues = nodes.filter(node => {\n      if (!node) return false\n\n      const value = node[key]\n      if (_.isObject(value)) {\n        return !isEmptyObjectOrArray(value)\n      } else {\n        return isDefined(value)\n      }\n    })\n\n    // we want to keep track of nodes as we need it to get origin of data\n    const entries = nodeWithValues.map(node => {\n      const value = node[key]\n      return {\n        value,\n        parent: node,\n        ...extractTypes(value),\n      }\n    })\n\n    const value = extractFromEntries(entries, nextSelector, key)\n    if (!isDefined(value)) continue\n\n    example[key] = value\n  }\n\n  return example\n}\n\nconst buildFieldEnumValues = (options: ExampleValueOptions) => {\n  const enumValues = {}\n  const values = flatten(getExampleValues(options), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\nlet typeExampleValues: Map<string, Object> = new Map()\n\nconst clearTypeExampleValues = () => {\n  typeExampleValues.clear()\n  typeConflictReporter.clearConflicts()\n}\n\ntype ExampleValueOptions = {\n  nodes: Object[],\n  typeName?: string,\n  ignoreFields?: string[],\n}\n\nconst getExampleValues = ({\n  nodes,\n  typeName,\n  ignoreFields,\n}: ExampleValueOptions): ExampleValue => {\n  const cachedValue = typeName && typeExampleValues.get(typeName)\n\n  // if type is defined and is in example value cache return it\n  if (cachedValue) return cachedValue\n\n  // if nodes were passed extract field example from it\n  if (nodes && nodes.length > 0) {\n    const exampleValue = extractFieldExamples(\n      nodes,\n      typeName || ``,\n      ignoreFields\n    )\n    // if type is set - cache results\n    if (typeName) typeExampleValues.set(typeName, exampleValue)\n    return exampleValue\n  }\n\n  return {}\n}\n\n// extract a list of field names\n// nested objects get flattened to \"outer___inner\" which will be converted back to\n// \"outer.inner\" by run-sift\nconst extractFieldNames = (nodes: Object[]) => {\n  const values = flatten(\n    getExampleValues({\n      nodes,\n      typeName: _.get(nodes[0], `internal.type`),\n    }),\n    {\n      maxDepth: 3,\n      safe: true, // don't flatten arrays.\n      delimiter: `___`,\n    }\n  )\n\n  return Object.keys(values)\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  buildFieldEnumValues,\n  extractFieldNames,\n  isEmptyObjectOrArray,\n  clearTypeExampleValues,\n  getExampleValues,\n}\n"],"file":"data-tree-utils.js"}